
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>proxy: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/buhuipao/anyproxy/pkg/proxy/client.go (55.6%)</option>
				
				<option value="file1">github.com/buhuipao/anyproxy/pkg/proxy/connection_wrapper.go (100.0%)</option>
				
				<option value="file2">github.com/buhuipao/anyproxy/pkg/proxy/gateway.go (5.4%)</option>
				
				<option value="file3">github.com/buhuipao/anyproxy/pkg/proxy/httpproxy.go (65.5%)</option>
				
				<option value="file4">github.com/buhuipao/anyproxy/pkg/proxy/socks5proxy.go (81.8%)</option>
				
				<option value="file5">github.com/buhuipao/anyproxy/pkg/proxy/websocket_writer.go (73.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package proxy

import (
        "crypto/tls"
        "crypto/x509"
        "encoding/base64"
        "fmt"
        "io"
        "log"
        "net"
        "net/http"
        "net/url"
        "os"
        "strings"
        "sync"
        "time"

        "github.com/buhuipao/anyproxy/pkg/config"
        "github.com/gorilla/websocket"
        "github.com/rs/xid"
)

const (
        writeBufSize = 4096
)

// ProxyClient represents the proxy client
type ProxyClient struct {
        config     *config.ClientConfig
        wsConn     *websocket.Conn
        writer     *WebSocketWriter
        writeBuf   chan interface{}
        connsMu    sync.RWMutex
        conns      map[string]net.Conn
        msgChans   map[string]chan map[string]interface{} // Message channels per connection
        msgChansMu sync.RWMutex
        stopCh     chan struct{}
        wg         sync.WaitGroup
}

// NewClient creates a new proxy client
func NewClient(cfg *config.ClientConfig) (*ProxyClient, error) <span class="cov8" title="1">{
        return &amp;ProxyClient{
                config:   cfg,
                conns:    make(map[string]net.Conn),
                msgChans: make(map[string]chan map[string]interface{}),
                stopCh:   make(chan struct{}),
                writeBuf: make(chan interface{}, writeBufSize),
        }, nil
}</span>

// Start starts the client with automatic reconnection
func (c *ProxyClient) Start() error <span class="cov8" title="1">{
        // Start the main connection loop with reconnection
        c.wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer c.wg.Done()
                c.connectionLoop()
        }</span>()

        <span class="cov8" title="1">return nil</span>
}

// Stop stops the client gracefully
func (c *ProxyClient) Stop() error <span class="cov8" title="1">{
        log.Printf("Stopping client gracefully...")

        // Step 1: Signal all goroutines to stop accepting new work
        close(c.stopCh)

        // Step 2: Give existing connections time to finish current operations
        log.Printf("Waiting for active connections to finish...")
        time.Sleep(500 * time.Millisecond)

        // Step 3: Close WebSocket connection to stop receiving new requests
        if c.wsConn != nil </span><span class="cov0" title="0">{
                c.wsConn.Close()
        }</span>

        // Step 4: Give a bit more time for pending writes to complete
        <span class="cov8" title="1">time.Sleep(200 * time.Millisecond)

        // Step 5: Stop WebSocket writer
        if c.writer != nil </span><span class="cov0" title="0">{
                c.writer.Stop()
        }</span>

        // Step 6: Close all remaining connections
        <span class="cov8" title="1">c.closeAllConnections()

        // Step 7: Wait for all goroutines to finish with timeout
        done := make(chan struct{})
        go func() </span><span class="cov8" title="1">{
                c.wg.Wait()
                close(done)
        }</span>()

        <span class="cov8" title="1">select </span>{
        case &lt;-done:<span class="cov8" title="1">
                log.Printf("All client goroutines finished gracefully")</span>
        case &lt;-time.After(3 * time.Second):<span class="cov0" title="0">
                log.Printf("Warning: timeout waiting for client goroutines to finish")</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// connectionLoop handles connection and reconnection logic
func (c *ProxyClient) connectionLoop() <span class="cov8" title="1">{
        backoff := 1 * time.Second
        maxBackoff := 60 * time.Second

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-c.stopCh:<span class="cov0" title="0">
                        return</span>
                default:<span class="cov8" title="1"></span>
                }

                // Attempt to connect
                <span class="cov8" title="1">if err := c.connect(); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Failed to connect to gateway: %v, retrying in %v", err, backoff)

                        // Wait before retry
                        select </span>{
                        case &lt;-c.stopCh:<span class="cov8" title="1">
                                return</span>
                        case &lt;-time.After(backoff):<span class="cov0" title="0"></span>
                        }

                        // Exponential backoff
                        <span class="cov0" title="0">backoff *= 2
                        if backoff &gt; maxBackoff </span><span class="cov0" title="0">{
                                backoff = maxBackoff
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Reset backoff on successful connection
                <span class="cov0" title="0">backoff = 1 * time.Second
                log.Printf("Successfully connected to gateway")

                // Handle messages until connection fails
                c.handleMessages()

                // Connection lost, cleanup and retry
                log.Printf("Connection to gateway lost, cleaning up and retrying...")
                c.cleanup()</span>
        }
}

// cleanup cleans up resources after connection loss
func (c *ProxyClient) cleanup() <span class="cov0" title="0">{
        // Stop writer
        c.writer.Stop()
        close(c.writeBuf)

        // Close WebSocket connection
        c.wsConn.Close()
        c.wsConn = nil

        // Close all connections
        c.closeAllConnections()

        // Recreate write buffer for next connection
        c.writeBuf = make(chan interface{}, writeBufSize)
}</span>

// closeAllConnections closes all active connections
func (c *ProxyClient) closeAllConnections() <span class="cov8" title="1">{
        c.connsMu.Lock()
        defer c.connsMu.Unlock()
        for _, conn := range c.conns </span><span class="cov8" title="1">{
                conn.Close()
        }</span>
        <span class="cov8" title="1">c.conns = make(map[string]net.Conn)</span>
}

// connect establishes a WebSocket connection to the gateway
func (c *ProxyClient) connect() error <span class="cov8" title="1">{
        // Create TLS configuration
        tlsConfig, err := c.createTLSConfig()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Parse the gateway URL
        <span class="cov8" title="1">gatewayURL := url.URL{
                Scheme: "wss",
                Host:   c.config.GatewayAddr,
                Path:   "/ws",
        }

        // Set up headers
        headers := http.Header{}
        headers.Set("X-Client-ID", c.generateClientID())

        // Use Basic Auth for authentication
        auth := base64.StdEncoding.EncodeToString(
                []byte(c.config.AuthUsername + ":" + c.config.AuthPassword),
        )
        headers.Set("Authorization", "Basic "+auth)

        // Create WebSocket dialer
        dialer := websocket.Dialer{
                TLSClientConfig:  tlsConfig,
                Proxy:            http.ProxyFromEnvironment,
                HandshakeTimeout: 10 * time.Second,
        }

        // Connect to WebSocket
        conn, _, err := dialer.Dial(gatewayURL.String(), headers)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to connect to WebSocket: %v", err)
        }</span>

        <span class="cov0" title="0">c.wsConn = conn

        // Create and start WebSocket writer
        c.writer = NewWebSocketWriter(conn, c.writeBuf)
        c.writer.Start()

        return nil</span>
}

func (c *ProxyClient) generateClientID() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s-%s", c.config.ClientID, xid.New().String())
}</span>

// createTLSConfig creates a TLS configuration for the client
func (c *ProxyClient) createTLSConfig() (*tls.Config, error) <span class="cov8" title="1">{
        tlsConfig := &amp;tls.Config{
                MinVersion: tls.VersionTLS12,
                ServerName: strings.Split(c.config.GatewayAddr, ":")[0],
        }

        // If a certificate file is provided, load it
        if c.config.GatewayTLSCert != "" </span><span class="cov8" title="1">{
                caCert, err := os.ReadFile(c.config.GatewayTLSCert)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to read gateway TLS certificate: %v", err)
                }</span>

                <span class="cov0" title="0">caCertPool := x509.NewCertPool()
                caCertPool.AppendCertsFromPEM(caCert)
                tlsConfig.RootCAs = caCertPool</span>
        }

        <span class="cov8" title="1">return tlsConfig, nil</span>
}

// handleMessages processes incoming messages from the gateway
func (c *ProxyClient) handleMessages() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-c.stopCh:<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0"></span>
                }

                // Read message from gateway
                <span class="cov0" title="0">var msg map[string]interface{}
                if err := c.wsConn.ReadJSON(&amp;msg); err != nil </span><span class="cov0" title="0">{
                        log.Printf("WebSocket read error: %v", err)
                        return
                }</span>

                // Process message based on its type
                <span class="cov0" title="0">msgType, ok := msg["type"].(string)
                if !ok </span><span class="cov0" title="0">{
                        log.Printf("Invalid message format from gateway")
                        continue</span>
                }

                <span class="cov0" title="0">switch msgType </span>{
                case "connect", "data", "close":<span class="cov0" title="0">
                        // Route all messages to per-connection channels
                        c.routeMessage(msg)</span>
                default:<span class="cov0" title="0">
                        log.Printf("Unknown message type: %s", msgType)</span>
                }
        }
}

// routeMessage routes messages to the appropriate connection's message channel
func (c *ProxyClient) routeMessage(msg map[string]interface{}) <span class="cov8" title="1">{
        connID, ok := msg["id"].(string)
        if !ok </span><span class="cov8" title="1">{
                log.Printf("Invalid connection ID in message")
                return
        }</span>

        <span class="cov8" title="1">msgType, _ := msg["type"].(string)

        // For connect messages, create the channel first
        if msgType == "connect" </span><span class="cov8" title="1">{
                c.createMessageChannel(connID)
        }</span>

        <span class="cov8" title="1">c.msgChansMu.RLock()
        msgChan, exists := c.msgChans[connID]
        c.msgChansMu.RUnlock()

        if !exists </span><span class="cov8" title="1">{
                // Connection doesn't exist, ignore message
                return
        }</span>

        // Send message to connection's channel (non-blocking)
        <span class="cov8" title="1">select </span>{
        case msgChan &lt;- msg:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0">
                log.Printf("Message channel full for connection %s, dropping message", connID)</span>
        }
}

// createMessageChannel creates a message channel for a connection
func (c *ProxyClient) createMessageChannel(connID string) <span class="cov8" title="1">{
        c.msgChansMu.Lock()
        defer c.msgChansMu.Unlock()

        msgChan := make(chan map[string]interface{}, 100) // Buffer for 100 messages
        c.msgChans[connID] = msgChan

        // Start message processor for this connection
        c.wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer c.wg.Done()
                c.processConnectionMessages(connID, msgChan)
        }</span>()
}

// processConnectionMessages processes messages for a specific connection in order
func (c *ProxyClient) processConnectionMessages(connID string, msgChan chan map[string]interface{}) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-c.stopCh:<span class="cov8" title="1">
                        return</span>
                case msg, ok := &lt;-msgChan:<span class="cov8" title="1">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov8" title="1">msgType, _ := msg["type"].(string)
                        switch msgType </span>{
                        case "connect":<span class="cov8" title="1">
                                c.handleConnectMessage(msg)</span>
                        case "data":<span class="cov0" title="0">
                                c.handleDataMessage(msg)</span>
                        case "close":<span class="cov0" title="0">
                                c.handleCloseMessage(msg)
                                return</span> // Connection closed, stop processing
                        }
                }
        }
}

// handleConnectMessage processes a connect message from the gateway
func (c *ProxyClient) handleConnectMessage(msg map[string]interface{}) <span class="cov8" title="1">{
        // Extract connection information
        connID, ok := msg["id"].(string)
        if !ok </span><span class="cov0" title="0">{
                log.Printf("Invalid connection ID in connect message")
                return
        }</span>

        <span class="cov8" title="1">network, ok := msg["network"].(string)
        if !ok </span><span class="cov8" title="1">{
                log.Printf("Invalid network in connect message")
                return
        }</span>

        <span class="cov0" title="0">address, ok := msg["address"].(string)
        if !ok </span><span class="cov0" title="0">{
                log.Printf("Invalid address in connect message")
                return
        }</span>

        <span class="cov0" title="0">log.Printf("Handling connect request %s to %s://%s", connID, network, address)

        // Check if the connection is allowed
        if !c.isConnectionAllowed(address) </span><span class="cov0" title="0">{
                log.Printf("Connection to %s denied (forbidden host)", address)
                c.sendConnectResponse(connID, false, "Host is forbidden")
                return
        }</span>

        // Establish connection to the target
        <span class="cov0" title="0">conn, err := net.DialTimeout(network, address, 30*time.Second)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to connect to %s: %v", address, err)
                c.sendConnectResponse(connID, false, err.Error())
                return
        }</span>

        <span class="cov0" title="0">log.Printf("Successfully connected to %s for connection %s", address, connID)

        // Register the connection
        c.connsMu.Lock()
        c.conns[connID] = conn
        c.connsMu.Unlock()

        // Send success response
        if err := c.sendConnectResponse(connID, true, ""); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error sending connect_response: %v", err)
                c.cleanupConnection(connID)
                return
        }</span>

        // Start handling the connection
        <span class="cov0" title="0">c.wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer c.wg.Done()
                c.handleConnection(connID)
        }</span>()
}

// sendConnectResponse sends a connection response to the gateway
func (c *ProxyClient) sendConnectResponse(connID string, success bool, errorMsg string) error <span class="cov8" title="1">{
        response := map[string]interface{}{
                "type":    "connect_response",
                "id":      connID,
                "success": success,
        }

        if !success &amp;&amp; errorMsg != "" </span><span class="cov0" title="0">{
                response["error"] = errorMsg
        }</span>

        <span class="cov8" title="1">return c.writer.WriteJSON(response)</span>
}

// handleConnection reads from the target connection and sends data to gateway
func (c *ProxyClient) handleConnection(connID string) <span class="cov0" title="0">{
        log.Printf("Starting to handle connection %s", connID)

        // Get the connection
        c.connsMu.RLock()
        conn, ok := c.conns[connID]
        c.connsMu.RUnlock()
        if !ok </span><span class="cov0" title="0">{
                log.Printf("Unknown connection ID: %s", connID)
                return
        }</span>

        // Increase buffer size for better performance
        <span class="cov0" title="0">buffer := make([]byte, 32*1024) // 32KB buffer to match gateway

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-c.stopCh:<span class="cov0" title="0">
                        log.Printf("Client stopping, exiting connection handler %s", connID)
                        return</span>
                default:<span class="cov0" title="0"></span>
                }

                // Set reasonable read timeout for shutdown response
                <span class="cov0" title="0">conn.SetReadDeadline(time.Now().Add(5 * time.Second))

                n, err := conn.Read(buffer)
                if n &gt; 0 </span><span class="cov0" title="0">{
                        // Encode binary data as base64 string
                        encodedData := base64.StdEncoding.EncodeToString(buffer[:n])

                        writeErr := c.writer.WriteJSON(map[string]interface{}{
                                "type": "data",
                                "id":   connID,
                                "data": encodedData,
                        })
                        if writeErr != nil </span><span class="cov0" title="0">{
                                log.Printf("Error writing data to WebSocket for connection %s: %v", connID, writeErr)
                                c.cleanupConnection(connID)
                                return
                        }</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        if netErr, ok := err.(net.Error); ok &amp;&amp; netErr.Timeout() </span><span class="cov0" title="0">{
                                continue</span> // Continue on timeout without logging
                        }

                        <span class="cov0" title="0">if err != io.EOF </span><span class="cov0" title="0">{
                                log.Printf("Failed to read from connection %s: %v", connID, err)
                        }</span>

                        // Send close message to gateway
                        <span class="cov0" title="0">c.writer.WriteJSON(map[string]interface{}{
                                "type": "close",
                                "id":   connID,
                        })

                        c.cleanupConnection(connID)
                        return</span>
                }
        }
}

// isConnectionAllowed checks if a connection to the given address is allowed
func (c *ProxyClient) isConnectionAllowed(address string) bool <span class="cov8" title="1">{
        host := address
        if idx := strings.LastIndex(address, ":"); idx &gt; 0 </span><span class="cov8" title="1">{
                host = address[:idx]
        }</span>

        <span class="cov8" title="1">for _, forbidden := range c.config.ForbiddenHosts </span><span class="cov8" title="1">{
                if strings.HasSuffix(host, forbidden) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// handleDataMessage processes a data message from the gateway
func (c *ProxyClient) handleDataMessage(msg map[string]interface{}) <span class="cov8" title="1">{
        // Extract message information
        connID, ok := msg["id"].(string)
        if !ok </span><span class="cov8" title="1">{
                log.Printf("Invalid connection ID in data message")
                return
        }</span>

        <span class="cov8" title="1">dataStr, ok := msg["data"].(string)
        if !ok </span><span class="cov8" title="1">{
                log.Printf("Invalid data in data message for connection %s", connID)
                return
        }</span>

        // Decode base64 string back to []byte
        <span class="cov8" title="1">data, err := base64.StdEncoding.DecodeString(dataStr)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Failed to decode base64 data for connection %s: %v", connID, err)
                return
        }</span>

        // Get the connection
        <span class="cov8" title="1">c.connsMu.RLock()
        conn, ok := c.conns[connID]
        c.connsMu.RUnlock()
        if !ok </span><span class="cov8" title="1">{
                log.Printf("Unknown connection ID: %s", connID)
                return
        }</span>

        // Write data to the connection
        <span class="cov8" title="1">_, err = conn.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to write data to connection %s: %v", connID, err)
                c.cleanupConnection(connID)
                return
        }</span>
}

// handleCloseMessage processes a close message from the gateway
func (c *ProxyClient) handleCloseMessage(msg map[string]interface{}) <span class="cov8" title="1">{
        connID, ok := msg["id"].(string)
        if !ok </span><span class="cov8" title="1">{
                log.Printf("Invalid connection ID in close message")
                return
        }</span>

        <span class="cov8" title="1">c.cleanupConnection(connID)</span>
}

// cleanupConnection cleans up a connection
func (c *ProxyClient) cleanupConnection(connID string) <span class="cov8" title="1">{
        c.connsMu.Lock()
        conn, exists := c.conns[connID]
        if exists </span><span class="cov8" title="1">{
                delete(c.conns, connID)
        }</span>
        <span class="cov8" title="1">c.connsMu.Unlock()

        // Clean up message channel
        c.msgChansMu.Lock()
        if msgChan, exists := c.msgChans[connID]; exists </span><span class="cov8" title="1">{
                delete(c.msgChans, connID)
                close(msgChan)
        }</span>
        <span class="cov8" title="1">c.msgChansMu.Unlock()

        if exists &amp;&amp; conn != nil </span><span class="cov8" title="1">{
                conn.Close()
                log.Printf("Connection %s cleaned up", connID)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package proxy

import (
        "net"
)

// ConnWrapper wraps a net.Conn and provides custom LocalAddr and RemoteAddr
type ConnWrapper struct {
        net.Conn
        localAddr  net.Addr
        remoteAddr net.Addr
}

var _ net.Conn = (*ConnWrapper)(nil)

// NewConnWrapper creates a new connection wrapper with custom addresses
func NewConnWrapper(conn net.Conn, network, remoteAddress string) *ConnWrapper <span class="cov8" title="1">{
        // Create a fake local address (SOCKS5 server binding address)
        localAddr := &amp;net.TCPAddr{
                IP:   net.IPv4(127, 0, 0, 1),
                Port: 0, // Let the system assign a port
        }

        // Parse the remote address
        var remoteAddr net.Addr
        if host, port, err := net.SplitHostPort(remoteAddress); err == nil </span><span class="cov8" title="1">{
                if ip := net.ParseIP(host); ip != nil </span><span class="cov8" title="1">{
                        if network == "tcp" </span><span class="cov8" title="1">{
                                if portNum, err := net.LookupPort("tcp", port); err == nil </span><span class="cov8" title="1">{
                                        remoteAddr = &amp;net.TCPAddr{IP: ip, Port: portNum}
                                }</span>
                        } else<span class="cov8" title="1"> if network == "udp" </span><span class="cov8" title="1">{
                                if portNum, err := net.LookupPort("udp", port); err == nil </span><span class="cov8" title="1">{
                                        remoteAddr = &amp;net.UDPAddr{IP: ip, Port: portNum}
                                }</span>
                        }
                }
        }

        // Fallback to a default remote address if parsing failed
        <span class="cov8" title="1">if remoteAddr == nil </span><span class="cov8" title="1">{
                if network == "tcp" </span><span class="cov8" title="1">{
                        remoteAddr = &amp;net.TCPAddr{
                                IP:   net.IPv4(127, 0, 0, 1),
                                Port: 80,
                        }
                }</span> else<span class="cov8" title="1"> {
                        remoteAddr = &amp;net.UDPAddr{
                                IP:   net.IPv4(127, 0, 0, 1),
                                Port: 80,
                        }
                }</span>
        }

        <span class="cov8" title="1">wrapper := &amp;ConnWrapper{
                Conn:       conn,
                localAddr:  localAddr,
                remoteAddr: remoteAddr,
        }

        return wrapper</span>
}

// LocalAddr returns the local network address
func (cw *ConnWrapper) LocalAddr() net.Addr <span class="cov8" title="1">{
        return cw.localAddr
}</span>

// RemoteAddr returns the remote network address
func (cw *ConnWrapper) RemoteAddr() net.Addr <span class="cov8" title="1">{
        return cw.remoteAddr
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package proxy

import (
        "context"
        "crypto/tls"
        "encoding/base64"
        "fmt"
        "io"
        "log"
        "log/slog"
        "net"
        "net/http"
        "sync"
        "time"

        "github.com/buhuipao/anyproxy/pkg/config"
        "github.com/gorilla/websocket"
        "github.com/rs/xid"
)

// Gateway represents the proxy gateway server
type Gateway struct {
        config     *config.GatewayConfig
        httpServer *http.Server
        proxies    []GatewayProxy // Support multiple proxies
        upgrader   websocket.Upgrader
        clientsMu  sync.RWMutex
        clients    map[string]*ClientConn
        stopCh     chan struct{}
        wg         sync.WaitGroup
}

// NewGateway creates a new proxy gateway
func NewGateway(cfg *config.Config) (*Gateway, error) <span class="cov8" title="1">{
        gateway := &amp;Gateway{
                config:  &amp;cfg.Gateway,
                clients: make(map[string]*ClientConn),
                upgrader: websocket.Upgrader{
                        CheckOrigin: func(r *http.Request) bool </span><span class="cov0" title="0">{
                                return true
                        }</span>,
                },
                stopCh: make(chan struct{}),
        }

        // Create a custom dial function that uses WebSocket connections
        <span class="cov8" title="1">dialFn := func(ctx context.Context, network, addr string) (net.Conn, error) </span><span class="cov0" title="0">{
                // Get a random client
                client, err := gateway.getRandomClient()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return client.dialNetwork(network, addr)</span>
        }

        // Create proxy instances based on configuration
        <span class="cov8" title="1">var proxies []GatewayProxy

        // Create HTTP proxy if configured
        if cfg.Proxy.HTTP.ListenAddr != "" </span><span class="cov8" title="1">{
                httpProxy, err := NewHTTPProxy(&amp;cfg.Proxy.HTTP, dialFn)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create HTTP proxy: %v", err)
                }</span>
                <span class="cov8" title="1">proxies = append(proxies, httpProxy)
                log.Printf("Created HTTP proxy on %s", cfg.Proxy.HTTP.ListenAddr)</span>
        }

        // Create SOCKS5 proxy if configured
        <span class="cov8" title="1">if cfg.Proxy.SOCKS5.ListenAddr != "" </span><span class="cov8" title="1">{
                socks5Proxy, err := NewSOCKS5Proxy(&amp;cfg.Proxy.SOCKS5, dialFn)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create SOCKS5 proxy: %v", err)
                }</span>
                <span class="cov8" title="1">proxies = append(proxies, socks5Proxy)
                log.Printf("Created SOCKS5 proxy on %s", cfg.Proxy.SOCKS5.ListenAddr)</span>
        }

        // Ensure at least one proxy is configured
        <span class="cov8" title="1">if len(proxies) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no proxy configured: please configure at least one of HTTP or SOCKS5 proxy")
        }</span>

        <span class="cov8" title="1">gateway.proxies = proxies

        return gateway, nil</span>
}

// Start starts the gateway
func (g *Gateway) Start() error <span class="cov0" title="0">{
        // Start the HTTP server for WebSocket connections
        if err := g.startHTTPServer(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Start all proxy servers
        <span class="cov0" title="0">for i, proxy := range g.proxies </span><span class="cov0" title="0">{
                if err := proxy.Start(); err != nil </span><span class="cov0" title="0">{
                        // If any proxy fails to start, stop the ones that already started
                        for j := 0; j &lt; i; j++ </span><span class="cov0" title="0">{
                                g.proxies[j].Stop()
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("failed to start proxy %d: %v", i, err)</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// startHTTPServer starts the HTTP server for WebSocket connections
func (g *Gateway) startHTTPServer() error <span class="cov0" title="0">{
        // Load TLS certificate and key
        cert, err := tls.LoadX509KeyPair(g.config.TLSCert, g.config.TLSKey)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load TLS certificate: %v", err)
        }</span>

        // Configure TLS
        <span class="cov0" title="0">tlsConfig := &amp;tls.Config{
                Certificates: []tls.Certificate{cert},
                MinVersion:   tls.VersionTLS12,
        }

        // Create HTTP server for WebSocket connections
        mux := http.NewServeMux()
        mux.HandleFunc("/ws", g.handleWebSocket)

        g.httpServer = &amp;http.Server{
                Addr:      g.config.ListenAddr,
                Handler:   mux,
                TLSConfig: tlsConfig,
        }

        // Start HTTP server in a separate goroutine
        g.wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer g.wg.Done()
                log.Printf("Starting WebSocket server on %s", g.config.ListenAddr)
                if err := g.httpServer.ListenAndServeTLS("", ""); err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Printf("HTTP server error: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">return nil</span>
}

// Stop stops the gateway gracefully
func (g *Gateway) Stop() error <span class="cov0" title="0">{
        log.Printf("Stopping gateway gracefully...")

        // Step 1: Signal all goroutines to stop
        close(g.stopCh)

        // Step 2: Stop accepting new connections
        ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
        defer cancel()
        if err := g.httpServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error shutting down HTTP server: %v", err)
        }</span>

        // Step 3: Stop all proxy servers
        <span class="cov0" title="0">for i, proxy := range g.proxies </span><span class="cov0" title="0">{
                if err := proxy.Stop(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error stopping proxy %d: %v", i, err)
                }</span>
        }

        // Step 4: Give clients time to finish processing
        <span class="cov0" title="0">log.Printf("Waiting for clients to finish processing...")
        time.Sleep(500 * time.Millisecond)

        // Step 5: Stop all client connections gracefully
        g.clientsMu.RLock()
        for _, client := range g.clients </span><span class="cov0" title="0">{
                client.Stop()
        }</span>
        <span class="cov0" title="0">g.clientsMu.RUnlock()

        // Step 6: Wait for all goroutines to finish
        done := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                g.wg.Wait()
                close(done)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-done:<span class="cov0" title="0">
                log.Printf("All gateway goroutines finished gracefully")</span>
        case &lt;-time.After(8 * time.Second):<span class="cov0" title="0">
                log.Printf("Warning: timeout waiting for gateway goroutines to finish")</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// handleWebSocket handles WebSocket connections from clients
func (g *Gateway) handleWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        clientID := r.Header.Get("X-Client-ID")
        if clientID == "" </span><span class="cov0" title="0">{
                http.Error(w, "Client ID is required", http.StatusBadRequest)
                return
        }</span>

        // Authenticate client
        <span class="cov0" title="0">username, password, ok := r.BasicAuth()
        if !ok || username != g.config.AuthUsername || password != g.config.AuthPassword </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        // Upgrade HTTP connection to WebSocket
        <span class="cov0" title="0">conn, err := g.upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to upgrade WebSocket connection: %v", err)
                return
        }</span>

        // Create WebSocket writer
        <span class="cov0" title="0">writeBuf := make(chan interface{}, writeBufSize)
        writer := NewWebSocketWriter(conn, writeBuf)
        writer.Start()

        // Create and register client
        client := &amp;ClientConn{
                ID:       clientID,
                Conn:     conn,
                Writer:   writer,
                writeBuf: writeBuf,
                Conns:    make(map[string]*ProxyConn),
                msgChans: make(map[string]chan map[string]interface{}),
                stopCh:   make(chan struct{}),
        }

        g.addClient(client)
        log.Printf("Client connected: %s", clientID)

        // Handle incoming messages from the client
        g.wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer g.wg.Done()
                defer func() </span><span class="cov0" title="0">{
                        client.Stop()
                        g.removeClient(client.ID)
                        log.Printf("Client disconnected: %s", client.ID)
                }</span>()
                <span class="cov0" title="0">client.handleMessage()</span>
        }()
}

// addClient adds a client to the gateway
func (g *Gateway) addClient(client *ClientConn) <span class="cov0" title="0">{
        g.clientsMu.Lock()
        defer g.clientsMu.Unlock()
        g.clients[client.ID] = client
}</span>

// removeClient removes a client from the gateway
func (g *Gateway) removeClient(clientID string) <span class="cov0" title="0">{
        g.clientsMu.Lock()
        defer g.clientsMu.Unlock()
        delete(g.clients, clientID)
}</span>

// getRandomClient returns a random available client
func (g *Gateway) getRandomClient() (*ClientConn, error) <span class="cov0" title="0">{
        g.clientsMu.RLock()
        defer g.clientsMu.RUnlock()

        if len(g.clients) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no clients available")
        }</span>

        // Return the first available client (simple implementation)
        <span class="cov0" title="0">for _, client := range g.clients </span><span class="cov0" title="0">{
                return client, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("no clients available")</span>
}

// ------------------------------------------------------------------------------------------------
// -------------------------------------- ClientConn and ProxyConn --------------------------------
// ------------------------------------------------------------------------------------------------

// ClientConn represents a connected proxy client
type ClientConn struct {
        ID         string
        Conn       *websocket.Conn
        Writer     *WebSocketWriter
        writeBuf   chan interface{}
        ConnsMu    sync.RWMutex
        Conns      map[string]*ProxyConn
        msgChans   map[string]chan map[string]interface{} // Message channels per connection
        msgChansMu sync.RWMutex
        stopOnce   sync.Once
        stopCh     chan struct{}
        wg         sync.WaitGroup
}

// ProxyConn represents a proxied connection
type ProxyConn struct {
        ID        string
        LocalConn net.Conn
        Done      chan struct{}
        once      sync.Once
}

// dialNetwork creates a connection and registers it with the client
func (c *ClientConn) dialNetwork(network, addr string) (net.Conn, error) <span class="cov0" title="0">{
        // Generate connection ID
        connID := xid.New().String()

        // Create a pipe to connect the client and the proxy
        pipe1, pipe2 := net.Pipe()

        // Create proxy connection
        proxyConn := &amp;ProxyConn{
                ID:        connID,
                Done:      make(chan struct{}),
                LocalConn: pipe2,
        }

        // Register the connection
        c.ConnsMu.Lock()
        c.Conns[connID] = proxyConn
        c.ConnsMu.Unlock()

        // Send connect request to client
        slog.Info("Sending connect request to client", "clientID", c.ID, "connID", connID, "addr", addr)
        err := c.Writer.WriteJSON(map[string]interface{}{
                "type":    "connect",
                "id":      connID,
                "network": network,
                "address": addr,
        })
        if err != nil </span><span class="cov0" title="0">{
                // Clean up on failure
                c.closeConnection(connID) // will close pipe2
                return nil, fmt.Errorf("failed to send connect request: %v", err)
        }</span>

        // Return the connection wrapper
        <span class="cov0" title="0">return NewConnWrapper(pipe1, network, addr), nil</span>
}

// Stop stops the client and cleans up resources gracefully
func (c *ClientConn) Stop() <span class="cov0" title="0">{
        c.stopOnce.Do(func() </span><span class="cov0" title="0">{
                slog.Info("Stopping client gracefully", "clientID", c.ID)

                // Step 1: Signal all goroutines to stop accepting new work
                close(c.stopCh)

                // Step 2: Give existing connections time to finish current operations
                slog.Info("Waiting for active connections to finish", "clientID", c.ID)
                time.Sleep(300 * time.Millisecond)

                // Step 3: Close write buffer to signal writer to stop
                close(c.writeBuf)

                // Step 4: Give writer time to drain remaining messages
                time.Sleep(200 * time.Millisecond)

                // Step 5: Stop writer
                c.Writer.Stop()

                // Step 6: Close WebSocket connection
                c.Conn.Close()

                // Step 7: Close all proxy connections using existing logic
                c.ConnsMu.RLock()
                connIDs := make([]string, 0, len(c.Conns))
                for connID := range c.Conns </span><span class="cov0" title="0">{
                        connIDs = append(connIDs, connID)
                }</span>
                <span class="cov0" title="0">c.ConnsMu.RUnlock()

                // Close connections one by one using existing closeConnection method
                for _, connID := range connIDs </span><span class="cov0" title="0">{
                        c.closeConnection(connID)
                }</span>

                // Step 8: Wait for all goroutines to finish with timeout
                <span class="cov0" title="0">done := make(chan struct{})
                go func() </span><span class="cov0" title="0">{
                        c.wg.Wait()
                        close(done)
                }</span>()

                <span class="cov0" title="0">select </span>{
                case &lt;-done:<span class="cov0" title="0">
                        slog.Info("All client goroutines finished gracefully", "clientID", c.ID)</span>
                case &lt;-time.After(2 * time.Second):<span class="cov0" title="0">
                        slog.Warn("Timeout waiting for client goroutines to finish", "clientID", c.ID)</span>
                }
        })
}

func (c *ClientConn) handleMessage() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-c.stopCh:<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0"></span>
                }

                // Read message from client
                <span class="cov0" title="0">var msg map[string]interface{}
                if err := c.Conn.ReadJSON(&amp;msg); err != nil </span><span class="cov0" title="0">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                log.Printf("WebSocket error: %v", err)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                // Process message based on its type
                <span class="cov0" title="0">msgType, ok := msg["type"].(string)
                if !ok </span><span class="cov0" title="0">{
                        log.Printf("Invalid message format from client %s", c.ID)
                        continue</span>
                }

                <span class="cov0" title="0">switch msgType </span>{
                case "connect_response", "data", "close":<span class="cov0" title="0">
                        // Route all messages to per-connection channels
                        c.routeMessage(msg)</span>
                default:<span class="cov0" title="0">
                        log.Printf("Unknown message type: %s", msgType)</span>
                }
        }
}

// routeMessage routes messages to the appropriate connection's message channel
func (c *ClientConn) routeMessage(msg map[string]interface{}) <span class="cov0" title="0">{
        connID, ok := msg["id"].(string)
        if !ok </span><span class="cov0" title="0">{
                log.Printf("Invalid connection ID in message")
                return
        }</span>

        <span class="cov0" title="0">msgType, _ := msg["type"].(string)

        // For connect_response messages, create the channel first if needed
        if msgType == "connect_response" </span><span class="cov0" title="0">{
                c.createMessageChannel(connID)
        }</span>

        <span class="cov0" title="0">c.msgChansMu.RLock()
        msgChan, exists := c.msgChans[connID]
        c.msgChansMu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                // Connection doesn't exist, ignore message
                return
        }</span>

        // Send message to connection's channel (non-blocking)
        <span class="cov0" title="0">select </span>{
        case msgChan &lt;- msg:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                log.Printf("Message channel full for connection %s, dropping message", connID)</span>
        }
}

// createMessageChannel creates a message channel for a connection
func (c *ClientConn) createMessageChannel(connID string) <span class="cov0" title="0">{
        c.msgChansMu.Lock()
        defer c.msgChansMu.Unlock()

        // Check if channel already exists
        if _, exists := c.msgChans[connID]; exists </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">msgChan := make(chan map[string]interface{}, 100) // Buffer for 100 messages
        c.msgChans[connID] = msgChan

        // Start message processor for this connection
        c.wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer c.wg.Done()
                c.processConnectionMessages(connID, msgChan)
        }</span>()
}

// processConnectionMessages processes messages for a specific connection in order
func (c *ClientConn) processConnectionMessages(connID string, msgChan chan map[string]interface{}) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-c.stopCh:<span class="cov0" title="0">
                        return</span>
                case msg, ok := &lt;-msgChan:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">msgType, _ := msg["type"].(string)
                        switch msgType </span>{
                        case "connect_response":<span class="cov0" title="0">
                                c.handleConnectResponseMessage(msg)</span>
                        case "data":<span class="cov0" title="0">
                                c.handleDataMessage(msg)</span>
                        case "close":<span class="cov0" title="0">
                                c.handleCloseMessage(msg)
                                return</span> // Connection closed, stop processing
                        }
                }
        }
}

// handleDataMessage processes data messages from clients
func (c *ClientConn) handleDataMessage(msg map[string]interface{}) <span class="cov0" title="0">{
        // Extract connection ID and data
        connID, ok := msg["id"].(string)
        if !ok </span><span class="cov0" title="0">{
                log.Printf("Invalid connection ID in data message from client %s", c.ID)
                return
        }</span>

        // WebSocket JSON messages encode binary data as base64 string
        <span class="cov0" title="0">dataStr, ok := msg["data"].(string)
        if !ok </span><span class="cov0" title="0">{
                log.Printf("Invalid data in data message for connection %s from client %s, expected string but got %T", connID, c.ID, msg["data"])
                return
        }</span>

        // Decode base64 string back to []byte
        <span class="cov0" title="0">data, err := base64.StdEncoding.DecodeString(dataStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to decode base64 data for connection %s from client %s: %v", connID, c.ID, err)
                return
        }</span>

        // Only log for larger transfers to reduce noise
        <span class="cov0" title="0">if len(data) &gt; 10000 </span><span class="cov0" title="0">{
                log.Printf("Gateway received %d bytes from client %s for connection %s", len(data), c.ID, connID)
        }</span>

        // Get the connection safely
        <span class="cov0" title="0">c.ConnsMu.RLock()
        proxyConn, ok := c.Conns[connID]
        c.ConnsMu.RUnlock()
        if !ok </span><span class="cov0" title="0">{
                log.Printf("Unknown connection ID: %s when handling data message from client %s", connID, c.ID)
                return
        }</span>

        // Write data to the local connection
        <span class="cov0" title="0">n, err := proxyConn.LocalConn.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to write %d bytes to local connection %s: %v", len(data), connID, err)
                c.closeConnection(connID)
                return
        }</span>

        // Only log for larger transfers
        <span class="cov0" title="0">if n &gt; 10000 </span><span class="cov0" title="0">{
                log.Printf("Gateway successfully wrote %d bytes to local connection %s", n, connID)
        }</span>
}

// handleCloseMessage processes close messages from clients
func (c *ClientConn) handleCloseMessage(msg map[string]interface{}) <span class="cov0" title="0">{
        // Extract connection ID
        connID, ok := msg["id"].(string)
        if !ok </span><span class="cov0" title="0">{
                log.Printf("Invalid connection ID in close message")
                return
        }</span>

        // Get the connection safely
        <span class="cov0" title="0">c.ConnsMu.RLock()
        _, ok = c.Conns[connID]
        c.ConnsMu.RUnlock()

        if !ok </span><span class="cov0" title="0">{
                log.Printf("Connection ID %s not found for client %s - may have already been closed", connID, c.ID)
                return
        }</span>

        <span class="cov0" title="0">log.Printf("Closing connection %s for client %s", connID, c.ID)
        c.closeConnection(connID)</span>
}

// handleConnectResponseMessage processes connect_response messages from clients
func (c *ClientConn) handleConnectResponseMessage(msg map[string]interface{}) <span class="cov0" title="0">{
        // Extract connection ID and success status
        connID, ok := msg["id"].(string)
        if !ok </span><span class="cov0" title="0">{
                log.Printf("Invalid connection ID in connect_response message")
                return
        }</span>

        <span class="cov0" title="0">c.ConnsMu.RLock()
        proxyConn, exists := c.Conns[connID]
        c.ConnsMu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                log.Printf("Connection %s not found for client %s", connID, c.ID)
                return
        }</span>

        <span class="cov0" title="0">success, ok := msg["success"].(bool)
        if !ok </span><span class="cov0" title="0">{
                log.Printf("Invalid success value in connect_response message")
                return
        }</span>

        <span class="cov0" title="0">if success </span><span class="cov0" title="0">{
                log.Printf("Connection %s established successfully by client %s", connID, c.ID)
                // Start handling the connection asynchronously
                c.wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer c.wg.Done()
                        c.handleConnection(proxyConn)
                }</span>()
                <span class="cov0" title="0">return</span>
        }

        // Connection failed - cleanup
        <span class="cov0" title="0">errMsg, _ := msg["error"].(string)
        log.Printf("Connection %s failed on client %s: %s", connID, c.ID, errMsg)
        c.closeConnection(connID)</span>
}

func (c *ClientConn) handleConnection(proxyConn *ProxyConn) <span class="cov0" title="0">{
        connID := proxyConn.ID
        log.Printf("Starting to handle gateway connection %s for client %s", connID, c.ID)

        // Increase buffer size for better performance
        buffer := make([]byte, 32*1024) // 32KB buffer
        totalBytes := 0

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-c.stopCh:<span class="cov0" title="0">
                        log.Printf("Gateway stopping, exiting connection handler %s", connID)
                        return</span>
                case &lt;-proxyConn.Done:<span class="cov0" title="0">
                        log.Printf("Connection %s done signal received", connID)
                        return</span>
                default:<span class="cov0" title="0"></span>
                }

                // Check if the connection is still valid
                <span class="cov0" title="0">c.ConnsMu.RLock()
                _, connExists := c.Conns[connID]
                c.ConnsMu.RUnlock()

                if !connExists </span><span class="cov0" title="0">{
                        log.Printf("Connection %s no longer exists for client %s", connID, c.ID)
                        return
                }</span>

                // Set reasonable read timeout for shutdown response
                <span class="cov0" title="0">proxyConn.LocalConn.SetReadDeadline(time.Now().Add(5 * time.Second))

                n, err := proxyConn.LocalConn.Read(buffer)
                // Remove verbose logging for performance
                if n &gt; 0 </span><span class="cov0" title="0">{
                        totalBytes += n
                        // Only log for larger transfers to reduce noise
                        if totalBytes%100000 == 0 || n &gt; 10000 </span><span class="cov0" title="0">{
                                log.Printf("Gateway read %d bytes from local connection %s (total: %d bytes)", n, connID, totalBytes)
                        }</span>

                        // Encode binary data as base64 string
                        <span class="cov0" title="0">encodedData := base64.StdEncoding.EncodeToString(buffer[:n])

                        // Send data through WebSocket writer
                        writeErr := c.Writer.WriteJSON(map[string]interface{}{
                                "type": "data",
                                "id":   connID,
                                "data": encodedData,
                        })
                        if writeErr != nil </span><span class="cov0" title="0">{
                                log.Printf("Error writing to WebSocket for connection %s: %v", connID, writeErr)
                                c.closeConnection(connID)
                                return
                        }</span>
                        // Only log for larger transfers
                        <span class="cov0" title="0">if n &gt; 10000 </span><span class="cov0" title="0">{
                                log.Printf("Gateway successfully sent %d bytes to client for connection %s", n, connID)
                        }</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        // Check if it's a timeout error
                        if netErr, ok := err.(net.Error); ok &amp;&amp; netErr.Timeout() </span><span class="cov0" title="0">{
                                // Reduce timeout logging noise
                                continue</span>
                        }

                        <span class="cov0" title="0">if err != io.EOF </span><span class="cov0" title="0">{
                                log.Printf("Error reading from server connection %s: %v (total bytes transferred: %d)", connID, err, totalBytes)
                        }</span> else<span class="cov0" title="0"> {
                                log.Printf("Gateway connection %s closed by local (EOF) after %d bytes", connID, totalBytes)
                        }</span>

                        // Notify client about connection close
                        <span class="cov0" title="0">closeErr := c.Writer.WriteJSON(map[string]interface{}{
                                "type": "close",
                                "id":   connID,
                        })
                        if closeErr != nil </span><span class="cov0" title="0">{
                                log.Printf("Error sending close message to client for connection %s: %v", connID, closeErr)
                        }</span>

                        <span class="cov0" title="0">c.closeConnection(connID)
                        return</span>
                }
        }
}

// closeConnection closes a connection and cleans up resources
func (c *ClientConn) closeConnection(connID string) <span class="cov0" title="0">{
        // Atomically remove from client's connection map
        c.ConnsMu.Lock()
        proxyConn, exists := c.Conns[connID]
        delete(c.Conns, connID)
        c.ConnsMu.Unlock()

        // Clean up message channel
        c.msgChansMu.Lock()
        if msgChan, exists := c.msgChans[connID]; exists </span><span class="cov0" title="0">{
                delete(c.msgChans, connID)
                close(msgChan)
        }</span>
        <span class="cov0" title="0">c.msgChansMu.Unlock()

        // Only proceed with cleanup if the connection existed
        if !exists </span><span class="cov0" title="0">{
                log.Printf("Connection %s already removed from client %s", connID, c.ID)
                return
        }</span>

        // Signal connection to stop
        <span class="cov0" title="0">select </span>{
        case &lt;-proxyConn.Done:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                close(proxyConn.Done)</span>
        }

        // Close the actual connection
        <span class="cov0" title="0">proxyConn.once.Do(func() </span><span class="cov0" title="0">{
                slog.Info("Closing local connection", "connID", proxyConn.ID)
                proxyConn.LocalConn.Close()
        }</span>)

        <span class="cov0" title="0">log.Printf("Connection %s closed and cleaned up for client %s", proxyConn.ID, c.ID)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package proxy

import (
        "bufio"
        "context"
        "crypto/tls"
        "encoding/base64"
        "fmt"
        "io"
        "log"
        "net"
        "net/http"
        "net/url"
        "strings"
        "time"

        "github.com/buhuipao/anyproxy/pkg/config"
)

// httpProxy implements the GatewayProxy interface for HTTP/HTTPS protocol
type httpProxy struct {
        config     *config.HTTPConfig
        server     *http.Server
        dialFunc   ProxyDialer
        listenAddr string
        listener   net.Listener
}

// NewHTTPProxy creates a new HTTP/HTTPS proxy
func NewHTTPProxy(cfg *config.HTTPConfig, dialFunc ProxyDialer) (GatewayProxy, error) <span class="cov8" title="1">{
        proxy := &amp;httpProxy{
                config:     cfg,
                dialFunc:   dialFunc,
                listenAddr: cfg.ListenAddr,
        }

        // Create HTTP server with custom handler
        // Don't use ServeMux as it doesn't handle CONNECT requests properly
        proxy.server = &amp;http.Server{
                Addr:         proxy.listenAddr,
                Handler:      proxy, // Use the proxy itself as the handler
                ReadTimeout:  30 * time.Second,
                WriteTimeout: 30 * time.Second,
                IdleTimeout:  60 * time.Second,
        }

        return proxy, nil
}</span>

// Start starts the HTTP proxy server
func (h *httpProxy) Start() error <span class="cov8" title="1">{
        // Create listener
        listener, err := net.Listen("tcp", h.listenAddr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to listen on %s: %v", h.listenAddr, err)
        }</span>
        <span class="cov8" title="1">h.listener = listener

        // Start HTTP proxy server in a separate goroutine
        go func() </span><span class="cov8" title="1">{
                log.Printf("Starting HTTP proxy server on %s", h.listenAddr)
                if err := h.server.Serve(listener); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Printf("HTTP proxy server error: %v", err)
                }</span>
        }()

        <span class="cov8" title="1">return nil</span>
}

// Stop stops the HTTP proxy server
func (h *httpProxy) Stop() error <span class="cov8" title="1">{
        log.Printf("Stopping HTTP proxy server on %s", h.listenAddr)

        // Graceful shutdown with timeout
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := h.server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Printf("HTTP proxy server shutdown error: %v", err)
                // Force close if graceful shutdown fails
                if h.listener != nil </span><span class="cov0" title="0">{
                        return h.listener.Close()
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// DialConn implements the GatewayProxy interface by using the dialFunc
func (h *httpProxy) DialConn(network, addr string) (net.Conn, error) <span class="cov0" title="0">{
        if h.dialFunc == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no dial function provided")
        }</span>
        <span class="cov0" title="0">return h.dialFunc(context.Background(), network, addr)</span>
}

// SetListenAddr sets the address on which the HTTP proxy server will listen
func (h *httpProxy) SetListenAddr(addr string) <span class="cov0" title="0">{
        h.listenAddr = addr
}</span>

// ServeHTTP implements the http.Handler interface
func (h *httpProxy) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        h.handleHTTP(w, r)
}</span>

// handleHTTP handles both HTTP and HTTPS requests
func (h *httpProxy) handleHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Check authentication if configured
        if h.config.AuthUsername != "" &amp;&amp; h.config.AuthPassword != "" </span><span class="cov8" title="1">{
                if !h.authenticate(r) </span><span class="cov8" title="1">{
                        w.Header().Set("Proxy-Authenticate", "Basic realm=\"Proxy\"")
                        http.Error(w, "Proxy Authentication Required", http.StatusProxyAuthRequired)
                        return
                }</span>
        }

        // Handle CONNECT method for HTTPS tunneling
        <span class="cov8" title="1">if r.Method == http.MethodConnect </span><span class="cov8" title="1">{
                h.handleConnect(w, r)
                return
        }</span>

        // Handle regular HTTP requests
        <span class="cov8" title="1">h.handleHTTPRequest(w, r)</span>
}

// authenticate checks proxy authentication
func (h *httpProxy) authenticate(r *http.Request) bool <span class="cov8" title="1">{
        auth := r.Header.Get("Proxy-Authorization")
        if auth == "" </span><span class="cov8" title="1">{
                return false
        }</span>

        // Parse Basic authentication
        <span class="cov8" title="1">const prefix = "Basic "
        if !strings.HasPrefix(auth, prefix) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">decoded, err := base64.StdEncoding.DecodeString(auth[len(prefix):])
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">credentials := string(decoded)
        parts := strings.SplitN(credentials, ":", 2)
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">username, password := parts[0], parts[1]
        return username == h.config.AuthUsername &amp;&amp; password == h.config.AuthPassword</span>
}

// handleConnect handles HTTPS CONNECT requests for tunneling
func (h *httpProxy) handleConnect(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Extract target host and port
        host := r.URL.Host
        if !strings.Contains(host, ":") </span><span class="cov0" title="0">{
                host += ":443" // Default HTTPS port
        }</span>

        <span class="cov8" title="1">log.Printf("CONNECT request to %s", host)

        // Hijack the connection first to handle raw TCP tunneling
        hijacker, ok := w.(http.Hijacker)
        if !ok </span><span class="cov0" title="0">{
                log.Printf("Hijacking not supported")
                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">clientConn, clientBuf, err := hijacker.Hijack()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to hijack connection: %v", err)
                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer clientConn.Close()

        // Create connection to target through the dial function
        targetConn, err := h.dialFunc(r.Context(), "tcp", host)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to connect to %s: %v", host, err)
                // Send error response manually since we've hijacked the connection
                clientConn.Write([]byte("HTTP/1.1 502 Bad Gateway\r\n\r\n"))
                return
        }</span>
        <span class="cov8" title="1">defer targetConn.Close()

        // Send 200 Connection Established response manually
        _, err = clientConn.Write([]byte("HTTP/1.1 200 Connection Established\r\n\r\n"))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to send CONNECT response: %v", err)
                return
        }</span>

        // Handle any buffered data from the client
        <span class="cov8" title="1">if clientBuf != nil &amp;&amp; clientBuf.Reader.Buffered() &gt; 0 </span><span class="cov0" title="0">{
                bufferedData := make([]byte, clientBuf.Reader.Buffered())
                clientBuf.Reader.Read(bufferedData)
                targetConn.Write(bufferedData)
        }</span>

        // Start bidirectional data transfer
        <span class="cov8" title="1">go h.transfer(targetConn, clientConn, "target-&gt;client")
        h.transfer(clientConn, targetConn, "client-&gt;target")

        log.Printf("CONNECT tunnel to %s closed", host)</span>
}

// handleHTTPRequest handles regular HTTP requests (non-CONNECT)
func (h *httpProxy) handleHTTPRequest(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Parse target URL
        targetURL := r.URL
        if !targetURL.IsAbs() </span><span class="cov0" title="0">{
                // If URL is not absolute, construct it from Host header
                scheme := "http"
                if r.TLS != nil </span><span class="cov0" title="0">{
                        scheme = "https"
                }</span>
                <span class="cov0" title="0">targetURL = &amp;url.URL{
                        Scheme:   scheme,
                        Host:     r.Host,
                        Path:     r.URL.Path,
                        RawQuery: r.URL.RawQuery,
                }</span>
        }

        <span class="cov8" title="1">log.Printf("HTTP request to %s", targetURL.String())

        // Create connection to target
        host := targetURL.Host
        if !strings.Contains(host, ":") </span><span class="cov0" title="0">{
                if targetURL.Scheme == "https" </span><span class="cov0" title="0">{
                        host += ":443"
                }</span> else<span class="cov0" title="0"> {
                        host += ":80"
                }</span>
        }

        <span class="cov8" title="1">targetConn, err := h.dialFunc(r.Context(), "tcp", host)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to connect to %s: %v", host, err)
                http.Error(w, "Bad Gateway", http.StatusBadGateway)
                return
        }</span>
        <span class="cov8" title="1">defer targetConn.Close()

        // For HTTPS, wrap with TLS
        if targetURL.Scheme == "https" </span><span class="cov0" title="0">{
                tlsConn := tls.Client(targetConn, &amp;tls.Config{
                        ServerName: strings.Split(host, ":")[0],
                })
                targetConn = tlsConn
        }</span>

        // Remove proxy-specific headers
        <span class="cov8" title="1">r.Header.Del("Proxy-Authorization")
        r.Header.Del("Proxy-Connection")

        // Set Connection header for HTTP/1.1
        r.Header.Set("Connection", "close")

        // Write request to target server
        if err := r.Write(targetConn); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to write request to target: %v", err)
                http.Error(w, "Bad Gateway", http.StatusBadGateway)
                return
        }</span>

        // Read response from target server
        <span class="cov8" title="1">targetReader := bufio.NewReader(targetConn)
        resp, err := http.ReadResponse(targetReader, r)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to read response from target: %v", err)
                http.Error(w, "Bad Gateway", http.StatusBadGateway)
                return
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Copy response headers
        for key, values := range resp.Header </span><span class="cov8" title="1">{
                for _, value := range values </span><span class="cov8" title="1">{
                        w.Header().Add(key, value)
                }</span>
        }

        // Set status code
        <span class="cov8" title="1">w.WriteHeader(resp.StatusCode)

        // Copy response body
        _, err = io.Copy(w, resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to copy response body: %v", err)
        }</span>

        <span class="cov8" title="1">log.Printf("HTTP request to %s completed", targetURL.String())</span>
}

// transfer copies data between two connections
func (h *httpProxy) transfer(dst, src net.Conn, direction string) <span class="cov8" title="1">{
        buffer := make([]byte, 32*1024) // 32KB buffer
        totalBytes := int64(0)

        for </span><span class="cov8" title="1">{
                // Set read timeout
                src.SetReadDeadline(time.Now().Add(30 * time.Second))

                n, err := src.Read(buffer)
                if n &gt; 0 </span><span class="cov8" title="1">{
                        totalBytes += int64(n)

                        // Set write timeout
                        dst.SetWriteDeadline(time.Now().Add(30 * time.Second))

                        _, writeErr := dst.Write(buffer[:n])
                        if writeErr != nil </span><span class="cov0" title="0">{
                                log.Printf("Transfer %s write error: %v (transferred %d bytes)", direction, writeErr, totalBytes)
                                return
                        }</span>
                }

                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        if err != io.EOF </span><span class="cov8" title="1">{
                                log.Printf("Transfer %s read error: %v (transferred %d bytes)", direction, err, totalBytes)
                        }</span> else<span class="cov8" title="1"> {
                                log.Printf("Transfer %s completed: %d bytes", direction, totalBytes)
                        }</span>
                        <span class="cov8" title="1">return</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package proxy

import (
        "context"
        "fmt"
        "log"
        "net"

        "github.com/buhuipao/anyproxy/pkg/config"
        "github.com/things-go/go-socks5"
)

// socks5Proxy implements the GatewayProxy interface for SOCKS5 protocol
type socks5Proxy struct {
        config     *config.SOCKS5Config
        server     *socks5.Server
        dialFunc   ProxyDialer
        listenAddr string
        listener   net.Listener
}

// NewSOCKS5Proxy creates a new SOCKS5 proxy
func NewSOCKS5Proxy(cfg *config.SOCKS5Config, dialFunc ProxyDialer) (GatewayProxy, error) <span class="cov8" title="1">{
        socks5Auths := []socks5.Authenticator{}
        if cfg.AuthUsername != "" &amp;&amp; cfg.AuthPassword != "" </span><span class="cov8" title="1">{
                // Create authentication store with username/password from config
                socks5Auths = append(socks5Auths, &amp;socks5.UserPassAuthenticator{Credentials: socks5.StaticCredentials{
                        cfg.AuthUsername: cfg.AuthPassword,
                }})
        }</span>

        // Create SOCKS5 server
        <span class="cov8" title="1">server := socks5.NewServer(
                socks5.WithAuthMethods(socks5Auths),
                socks5.WithDial(dialFunc),
                socks5.WithLogger(socks5.NewLogger(log.Default())),
                // socks5.WithResolver(&amp;ForwardDNSResolver{}),
        )

        return &amp;socks5Proxy{
                config:     cfg,
                server:     server,
                dialFunc:   dialFunc,
                listenAddr: cfg.ListenAddr,
        }, nil</span>
}

// Start starts the SOCKS5 server
func (s *socks5Proxy) Start() error <span class="cov8" title="1">{
        // Create listener
        listener, err := net.Listen("tcp", s.listenAddr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to listen on %s: %v", s.listenAddr, err)
        }</span>
        <span class="cov8" title="1">s.listener = listener

        // Start SOCKS5 server in a separate goroutine
        go func() </span><span class="cov8" title="1">{
                log.Printf("Starting SOCKS5 server on %s", s.listenAddr)
                if err := s.server.Serve(listener); err != nil </span><span class="cov8" title="1">{
                        log.Printf("SOCKS5 server error: %v", err)
                }</span>
        }()

        <span class="cov8" title="1">return nil</span>
}

// Stop stops the SOCKS5 server
func (s *socks5Proxy) Stop() error <span class="cov8" title="1">{
        if s.listener != nil </span><span class="cov8" title="1">{
                log.Printf("Stopping SOCKS5 server on %s", s.listenAddr)
                return s.listener.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DialConn implements the GatewayProxy interface by using the dialFunc
func (s *socks5Proxy) DialConn(network, addr string) (net.Conn, error) <span class="cov8" title="1">{
        if s.dialFunc == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no dial function provided")
        }</span>
        <span class="cov8" title="1">return s.dialFunc(context.Background(), network, addr)</span>
}

// SetListenAddr sets the address on which the SOCKS5 server will listen
func (s *socks5Proxy) SetListenAddr(addr string) <span class="cov0" title="0">{
        s.listenAddr = addr
}</span>

/*
type ForwardDNSResolver struct {
        resolver *net.Resolver
}

func (r *ForwardDNSResolver) Resolve(ctx context.Context, name string) (context.Context, net.IP, error) {
        ips, err := r.resolver.LookupIP(ctx, "ip", name)
        if err != nil {
                return ctx, nil, err
        }

        return ctx, ips[0], nil
}
*/
</pre>
		
		<pre class="file" id="file5" style="display: none">package proxy

import (
        "log/slog"
        "sync"

        "github.com/gorilla/websocket"
)

// WebSocketWriter manages WebSocket write operations in a single goroutine
// The caller is responsible for closing writeCh to prevent resource leaks
type WebSocketWriter struct {
        conn    *websocket.Conn
        writeCh chan interface{}
        stopCh  chan struct{}
        once    sync.Once
        wg      sync.WaitGroup
}

// NewWebSocketWriter creates a new WebSocket writer
func NewWebSocketWriter(conn *websocket.Conn, writeCh chan interface{}) *WebSocketWriter <span class="cov8" title="1">{
        return &amp;WebSocketWriter{
                conn:    conn,
                writeCh: writeCh,
                stopCh:  make(chan struct{}),
        }
}</span>

// Start starts the writer goroutine
func (w *WebSocketWriter) Start() <span class="cov8" title="1">{
        w.wg.Add(1)
        go w.writeLoop()
}</span>

// Stop stops the writer and waits for completion
func (w *WebSocketWriter) Stop() <span class="cov8" title="1">{
        w.once.Do(func() </span><span class="cov8" title="1">{
                close(w.stopCh)
                // wait for writeLoop to finish, and all messages to be written to conn
                w.wg.Wait()
                w.conn.Close()
        }</span>)
}

// WriteJSON queues a JSON message for writing
func (w *WebSocketWriter) WriteJSON(v interface{}) error <span class="cov8" title="1">{
        // First check if already stopped
        select </span>{
        case &lt;-w.stopCh:<span class="cov8" title="1">
                return websocket.ErrCloseSent</span>
        default:<span class="cov8" title="1"></span>
        }

        // Then try to write or handle stop signal
        <span class="cov8" title="1">select </span>{
        case w.writeCh &lt;- v:<span class="cov8" title="1">
                return nil</span>
        case &lt;-w.stopCh:<span class="cov0" title="0">
                return websocket.ErrCloseSent</span>
        default:<span class="cov0" title="0">
                slog.Error("WebSocket write channel full, dropping message")
                return nil</span>
        }
}

// writeLoop processes messages in a single goroutine to ensure order
func (w *WebSocketWriter) writeLoop() <span class="cov8" title="1">{
        defer w.wg.Done()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-w.stopCh:<span class="cov8" title="1">
                        // Drain remaining messages to preserve order
                        w.drainMessages()
                        return</span>

                case msg := &lt;-w.writeCh:<span class="cov8" title="1">
                        if err := w.conn.WriteJSON(msg); err != nil </span><span class="cov0" title="0">{
                                slog.Error("WebSocket write error", "error", err)
                                go w.Stop() // Auto-stop on write errors
                                return
                        }</span>
                }
        }
}

// drainMessages processes remaining messages before shutdown
func (w *WebSocketWriter) drainMessages() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case msg, ok := &lt;-w.writeCh:<span class="cov8" title="1">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov8" title="1">if err := w.conn.WriteJSON(msg); err != nil </span><span class="cov0" title="0">{
                                slog.Error("Error writing final message", "error", err)
                        }</span>
                default:<span class="cov8" title="1">
                        return</span>
                }
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
